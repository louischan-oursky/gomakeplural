// Generated by https://github.com/gotnospirit/makeplural
// at 2019-05-07T15:21:55+08:00
//
// URL: https://github.com/unicode-cldr/cldr-core/raw/master/supplemental/ordinals.json
// $Revision: 14855 $
//
// URL: https://github.com/unicode-cldr/cldr-core/raw/master/supplemental/plurals.json
// $Revision: 14885 $

package plural

import (
	"fmt"
	"math"
	"strconv"

	"golang.org/x/text/language"
)

func mod(x, y float64) float64 {
	return math.Mod(x, y)
}

func float(v interface{}) float64 {
	switch v.(type) {
	case int:
		return float64(v.(int))

	case int64:
		return float64(v.(int64))

	case float64:
		return v.(float64)

	case string:
		floatval, err := strconv.ParseFloat(v.(string), 64)
		if nil != err {
			return 0.0
		}
		return floatval
	}
	return 0.0
}

var plural_funcs = make(map[language.Tag]func(interface{}, bool) string)

func init() {

	plural_funcs[language.MustParse("af")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ak")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("am")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ar")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n100 := mod(n, 100)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case n == 1:
			return "one"

		case n == 2:
			return "two"

		case p && n100 >= 3 && n100 <= 10:
			return "few"

		case p && n100 >= 11 && n100 <= 99:
			return "many"
		}
	}

	plural_funcs[language.MustParse("ars")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n100 := mod(n, 100)

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case n == 1:
			return "one"

		case n == 2:
			return "two"

		case p && n100 >= 3 && n100 <= 10:
			return "few"

		case p && n100 >= 11 && n100 <= 99:
			return "many"
		}
	}

	plural_funcs[language.MustParse("as")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"

			case n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("asa")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ast")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("az")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)
		i10 := i % 10
		i100 := i % 100
		i1000 := i % 1000

		if ordinal {
			switch {
			default:
				return "other"

			case i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8 || i100 == 20 || i100 == 50 || i100 == 70 || i100 == 80:
				return "one"

			case i10 == 3 || i10 == 4 || i1000 == 100 || i1000 == 200 || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700 || i1000 == 800 || i1000 == 900:
				return "few"

			case i == 0 || i10 == 6 || i100 == 40 || i100 == 60 || i100 == 90:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("be")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n10 := mod(n, 10)
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case (n10 == 2 || n10 == 3) && n100 != 12 && n100 != 13:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case n10 == 1 && n100 != 11:
			return "one"

		case p && n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14):
			return "few"

		case n10 == 0 || p && n10 >= 5 && n10 <= 9 || p && n100 >= 11 && n100 <= 14:
			return "many"
		}
	}

	plural_funcs[language.MustParse("bem")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bez")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bg")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bm")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("bn")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"

			case n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bo")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("br")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n10 := mod(n, 10)
		n100 := mod(n, 100)
		n1000000 := mod(n, 1000000)

		switch {
		default:
			return "other"

		case n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91:
			return "one"

		case n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92:
			return "two"

		case p && (p && n10 >= 3 && n10 <= 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99):
			return "few"

		case n != 0 && n1000000 == 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("brx")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("bs")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100
		f10 := f % 10
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14):
			return "few"
		}
	}

	plural_funcs[language.MustParse("ca")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 3:
				return "one"

			case n == 2:
				return "two"

			case n == 4:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ce")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ceb")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		f10 := f % 10

		switch {
		default:
			return "other"

		case v == 0 && (i == 1 || i == 2 || i == 3) || v == 0 && i10 != 4 && i10 != 6 && i10 != 9 || v != 0 && f10 != 4 && f10 != 6 && f10 != 9:
			return "one"
		}
	}

	plural_funcs[language.MustParse("cgg")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("chr")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ckb")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("cs")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case i >= 2 && i <= 4 && v == 0:
			return "few"

		case v != 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("cy")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 0 || n == 7 || n == 8 || n == 9:
				return "zero"

			case n == 1:
				return "one"

			case n == 2:
				return "two"

			case n == 3 || n == 4:
				return "few"

			case n == 5 || n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case n == 1:
			return "one"

		case n == 2:
			return "two"

		case n == 3:
			return "few"

		case n == 6:
			return "many"
		}
	}

	plural_funcs[language.MustParse("da")] = func(value interface{}, ordinal bool) string {
		_, i, n, _, t, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1 || t != 0 && (i == 0 || i == 1):
			return "one"
		}
	}

	plural_funcs[language.MustParse("de")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("dsb")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i100 := i % 100
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i100 == 1 || f100 == 1:
			return "one"

		case v == 0 && i100 == 2 || f100 == 2:
			return "two"

		case v == 0 && i100 >= 3 && i100 <= 4 || f100 >= 3 && f100 <= 4:
			return "few"
		}
	}

	plural_funcs[language.MustParse("dv")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("dz")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("ee")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("el")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("en")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)
		n10 := mod(n, 10)
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case n10 == 1 && n100 != 11:
				return "one"

			case n10 == 2 && n100 != 12:
				return "two"

			case n10 == 3 && n100 != 13:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("eo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("es")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("et")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("eu")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fa")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ff")] = func(value interface{}, ordinal bool) string {
		i := int64(float(value))

		switch {
		default:
			return "other"

		case i == 0 || i == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fi")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fil")] = func(value interface{}, ordinal bool) string {
		f, i, n, v, _, _ := finvtw(value)
		i10 := i % 10
		f10 := f % 10

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case v == 0 && (i == 1 || i == 2 || i == 3) || v == 0 && i10 != 4 && i10 != 6 && i10 != 9 || v != 0 && f10 != 4 && f10 != 6 && f10 != 9:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fr")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || i == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fur")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("fy")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ga")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"

		case p && n >= 3 && n <= 6:
			return "few"

		case p && n >= 7 && n <= 10:
			return "many"
		}
	}

	plural_funcs[language.MustParse("gd")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 11:
				return "one"

			case n == 2 || n == 12:
				return "two"

			case n == 3 || n == 13:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case n == 1 || n == 11:
			return "one"

		case n == 2 || n == 12:
			return "two"

		case p && n >= 3 && n <= 10 || p && n >= 13 && n <= 19:
			return "few"
		}
	}

	plural_funcs[language.MustParse("gl")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("gsw")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("gu")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"

			case n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("guw")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("gv")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1:
			return "one"

		case v == 0 && i10 == 2:
			return "two"

		case v == 0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80):
			return "few"

		case v != 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("ha")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("haw")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("he")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, w := finvtw(value)
		p := w == 0
		n10 := mod(n, 10)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case i == 2 && v == 0:
			return "two"

		case p && v == 0 && (n < 0 || n > 10) && n10 == 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("hi")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"

			case n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("hr")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100
		f10 := f % 10
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14):
			return "few"
		}
	}

	plural_funcs[language.MustParse("hsb")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i100 := i % 100
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i100 == 1 || f100 == 1:
			return "one"

		case v == 0 && i100 == 2 || f100 == 2:
			return "two"

		case v == 0 && i100 >= 3 && i100 <= 4 || f100 >= 3 && f100 <= 4:
			return "few"
		}
	}

	plural_funcs[language.MustParse("hu")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 5:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("hy")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case i == 0 || i == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ia")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("id")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("ig")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("ii")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("io")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("is")] = func(value interface{}, ordinal bool) string {
		_, i, _, _, t, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case t == 0 && i10 == 1 && i100 != 11 || t != 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("it")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 11 || n == 8 || n == 80 || n == 800:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("iu")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("ja")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("jbo")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("jgo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("yi")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("jmc")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("jv")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("ka")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)
		i100 := i % 100

		if ordinal {
			switch {
			default:
				return "other"

			case i == 1:
				return "one"

			case i == 0 || i100 >= 2 && i100 <= 20 || i100 == 40 || i100 == 60 || i100 == 80:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kab")] = func(value interface{}, ordinal bool) string {
		i := int64(float(value))

		switch {
		default:
			return "other"

		case i == 0 || i == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kaj")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kcg")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kde")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("kea")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("kk")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		n10 := mod(n, 10)

		if ordinal {
			switch {
			default:
				return "other"

			case n10 == 6 || n10 == 9 || n10 == 0 && n != 0:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kkj")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kl")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("km")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("kn")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ko")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("ks")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ksb")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ksh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ku")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("kw")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case p && n >= 1 && n <= 4 || p && n100 >= 1 && n100 <= 4 || p && n100 >= 21 && n100 <= 24 || p && n100 >= 41 && n100 <= 44 || p && n100 >= 61 && n100 <= 64 || p && n100 >= 81 && n100 <= 84:
				return "one"

			case n == 5 || n100 == 5:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case n == 1:
			return "one"

		case n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82:
			return "two"

		case n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83:
			return "few"

		case n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81):
			return "many"
		}
	}

	plural_funcs[language.MustParse("ky")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("lag")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		switch {
		default:
			return "other"

		case n == 0:
			return "zero"

		case (i == 0 || i == 1) && n != 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("lb")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("lg")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("lkt")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("ln")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("lo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		return "other"
	}

	plural_funcs[language.MustParse("lt")] = func(value interface{}, ordinal bool) string {
		f, _, n, _, _, w := finvtw(value)
		p := w == 0
		n10 := mod(n, 10)
		n100 := mod(n, 100)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case p && n10 == 1 && (n100 < 11 || n100 > 19):
			return "one"

		case p && n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19):
			return "few"

		case f != 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("lv")] = func(value interface{}, ordinal bool) string {
		f, _, n, v, _, w := finvtw(value)
		p := w == 0
		n10 := mod(n, 10)
		n100 := mod(n, 100)
		f100 := f % 100
		f10 := f % 10

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n10 == 0 || p && n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19:
			return "zero"

		case n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("mas")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("mg")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("mgo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("mk")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100
		f10 := f % 10
		f100 := f % 100

		if ordinal {
			switch {
			default:
				return "other"

			case i10 == 1 && i100 != 11:
				return "one"

			case i10 == 2 && i100 != 12:
				return "two"

			case (i10 == 7 || i10 == 8) && i100 != 17 && i100 != 18:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ml")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("mn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ro-MD")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, w := finvtw(value)
		p := w == 0
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case v != 0 || n == 0 || p && n100 >= 2 && n100 <= 19:
			return "few"
		}
	}

	plural_funcs[language.MustParse("mr")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ms")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		return "other"
	}

	plural_funcs[language.MustParse("mt")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n
		n100 := mod(n, 100)

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 0 || p && n100 >= 2 && n100 <= 10:
			return "few"

		case p && n100 >= 11 && n100 <= 19:
			return "many"
		}
	}

	plural_funcs[language.MustParse("my")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("nah")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("naq")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("nb")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nd")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ne")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		if ordinal {
			switch {
			default:
				return "other"

			case p && n >= 1 && n <= 4:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nl")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nnh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("no")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nqo")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("nr")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nso")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ny")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("nyn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("om")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("or")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1 || n == 5 || p && n >= 7 && n <= 9:
				return "one"

			case n == 2 || n == 3:
				return "two"

			case n == 4:
				return "few"

			case n == 6:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("os")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("pa")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("pap")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("pl")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14):
			return "few"

		case v == 0 && i != 1 && i10 >= 0 && i10 <= 1 || v == 0 && i10 >= 5 && i10 <= 9 || v == 0 && i100 >= 12 && i100 <= 14:
			return "many"
		}
	}

	plural_funcs[language.MustParse("prg")] = func(value interface{}, ordinal bool) string {
		f, _, n, v, _, w := finvtw(value)
		p := w == 0
		n10 := mod(n, 10)
		n100 := mod(n, 100)
		f100 := f % 100
		f10 := f % 10

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n10 == 0 || p && n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19:
			return "zero"

		case n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ps")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("pt")] = func(value interface{}, ordinal bool) string {
		i := int64(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i >= 0 && i <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("pt-PT")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("rm")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ro")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, w := finvtw(value)
		p := w == 0
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case v != 0 || n == 0 || p && n100 >= 2 && n100 <= 19:
			return "few"
		}
	}

	plural_funcs[language.MustParse("rof")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("und")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("ru")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14):
			return "few"

		case v == 0 && i10 == 0 || v == 0 && i10 >= 5 && i10 <= 9 || v == 0 && i100 >= 11 && i100 <= 14:
			return "many"
		}
	}

	plural_funcs[language.MustParse("rwk")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sah")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("saq")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sc")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 11 || n == 8 || n == 80 || n == 800:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("scn")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 11 || n == 8 || n == 80 || n == 800:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sd")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sdh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("se")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("seh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ses")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("sg")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("sr-Latn")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100
		f10 := f % 10
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14):
			return "few"
		}
	}

	plural_funcs[language.MustParse("shi")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)
		p := float64(i) == n

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"

		case p && n >= 2 && n <= 10:
			return "few"
		}
	}

	plural_funcs[language.MustParse("si")] = func(value interface{}, ordinal bool) string {
		f, i, n, _, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 0 || n == 1 || i == 0 && f == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sk")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"

		case i >= 2 && i <= 4 && v == 0:
			return "few"

		case v != 0:
			return "many"
		}
	}

	plural_funcs[language.MustParse("sl")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)
		i100 := i % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i100 == 1:
			return "one"

		case v == 0 && i100 == 2:
			return "two"

		case v == 0 && i100 >= 3 && i100 <= 4 || v != 0:
			return "few"
		}
	}

	plural_funcs[language.MustParse("sma")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("smi")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("smj")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("smn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("sms")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"

		case n == 2:
			return "two"
		}
	}

	plural_funcs[language.MustParse("sn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("so")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sq")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		n10 := mod(n, 10)
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"

			case n10 == 4 && n100 != 14:
				return "many"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sr")] = func(value interface{}, ordinal bool) string {
		f, i, _, v, _, _ := finvtw(value)
		i10 := i % 10
		i100 := i % 100
		f10 := f % 10
		f100 := f % 100

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14):
			return "few"
		}
	}

	plural_funcs[language.MustParse("ss")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ssy")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("st")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sv")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)
		n10 := mod(n, 10)
		n100 := mod(n, 100)

		if ordinal {
			switch {
			default:
				return "other"

			case (n10 == 1 || n10 == 2) && n100 != 11 && n100 != 12:
				return "one"
			}
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("sw")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("syr")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ta")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("te")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("teo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("th")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("ti")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("tig")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("tk")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		n10 := mod(n, 10)

		if ordinal {
			switch {
			default:
				return "other"

			case n10 == 6 || n10 == 9 || n == 10:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("tn")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("to")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("tr")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ts")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("tzm")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1 || p && n >= 11 && n <= 99:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ug")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("uk")] = func(value interface{}, ordinal bool) string {
		_, i, n, v, _, _ := finvtw(value)
		n10 := mod(n, 10)
		n100 := mod(n, 100)
		i10 := i % 10
		i100 := i % 100

		if ordinal {
			switch {
			default:
				return "other"

			case n10 == 3 && n100 != 13:
				return "few"
			}
		}

		switch {
		default:
			return "other"

		case v == 0 && i10 == 1 && i100 != 11:
			return "one"

		case v == 0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14):
			return "few"

		case v == 0 && i10 == 0 || v == 0 && i10 >= 5 && i10 <= 9 || v == 0 && i100 >= 11 && i100 <= 14:
			return "many"
		}
	}

	plural_funcs[language.MustParse("ur")] = func(value interface{}, ordinal bool) string {
		_, i, _, v, _, _ := finvtw(value)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 1 && v == 0:
			return "one"
		}
	}

	plural_funcs[language.MustParse("uz")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("ve")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("vi")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		if ordinal {
			switch {
			default:
				return "other"

			case n == 1:
				return "one"
			}
		}

		return "other"
	}

	plural_funcs[language.MustParse("vo")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("vun")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("wa")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))
		p := float64(int64(n)) == n

		switch {
		default:
			return "other"

		case p && n >= 0 && n <= 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("wae")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("wo")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("xh")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("xog")] = func(value interface{}, ordinal bool) string {
		n := math.Abs(float(value))

		switch {
		default:
			return "other"

		case n == 1:
			return "one"
		}
	}

	plural_funcs[language.MustParse("yo")] = func(value interface{}, ordinal bool) string {
		return "other"
	}

	plural_funcs[language.MustParse("yue")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("zh")] = func(value interface{}, ordinal bool) string {
		if ordinal {
			return "other"
		}

		return "other"
	}

	plural_funcs[language.MustParse("zu")] = func(value interface{}, ordinal bool) string {
		flt := float(value)
		n := math.Abs(flt)
		i := int64(flt)

		if ordinal {
			return "other"
		}

		switch {
		default:
			return "other"

		case i == 0 || n == 1:
			return "one"
		}
	}
}

func GetFunc(culture language.Tag) (func(interface{}, bool) string, error) {
	fn, ok := plural_funcs[culture]
	if !ok {
		return nil, fmt.Errorf("UnknownCulture: `%s`", culture)
	}
	return fn, nil
}
